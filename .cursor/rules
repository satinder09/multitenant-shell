# XoroERP Lite - Multi-Tenant SaaS Development Rules

## üèóÔ∏è Architecture & Design Patterns

### Multi-Tenant Database Strategy
- **Master Database**: Contains users, tenants, and tenant metadata
- **Tenant Databases**: Isolated per-tenant databases for data security
- **Always validate tenant context** before database operations
- **Use tenant middleware** to resolve tenant from subdomain/headers
- **Never mix master and tenant data** in the same database

### Route Design & Ordering
- **Specific routes MUST come before parameterized routes** in NestJS controllers
- **Route conflicts are common** - always test route precedence
- **Use descriptive route names** that clearly indicate purpose
- **Group related endpoints** logically (e.g., all tenant access in one controller)
- **Avoid multiple controllers with same prefix** - use unique controller paths
- **Check for controller conflicts** when routes return unexpected 404s
- **Use semantic controller prefixes** (e.g., 'tenant-access' vs 'tenants')

## üîß Backend Development (NestJS)

### Prisma & Database Management
- **Always run `npx prisma generate`** after schema changes
- **Reset migrations** when schema is out of sync: `npx prisma migrate reset`
- **Use separate Prisma clients** for master and tenant databases
- **Validate tenant isolation** - ensure no cross-tenant data leakage
- **Handle database connection errors** gracefully with proper fallbacks

### Authentication & Authorization
- **JWT tokens must include tenant context** for multi-tenant systems
- **Validate permissions** at both route and service levels
- **Use guards consistently** across protected endpoints
- **Implement proper session management** for impersonation scenarios
- **Audit all authentication events** for security compliance

### API Design
- **Return consistent error responses** with proper HTTP status codes
- **Use DTOs for all input validation** and type safety
- **Implement proper CORS configuration** for frontend integration
- **Add comprehensive logging** for debugging and monitoring
- **Handle edge cases** (missing data, invalid requests, etc.)

### Environment Configuration
- **NEVER use hardcoded domains or ports** - always use environment variables
- **Use consistent environment variable naming** across backend and frontend
- **Backend environment variables**: `BASE_DOMAIN`, `FRONTEND_PORT`, `PORT`
- **Frontend environment variables**: `NEXT_PUBLIC_BASE_DOMAIN`, `NEXT_PUBLIC_BACKEND_URL`, `FRONTEND_PORT`
- **Validate environment variables** at startup with proper error messages
- **Use fallback values** for development (e.g., `|| 'lvh.me'`, `|| '3000'`)
- **Update ALL references** when changing domain/port configuration
- **Test with different environment configurations** to ensure flexibility
- **Document required environment variables** in README and setup guides

## üé® Frontend Development (Next.js)

### State Management
- **Reset loading states** in all async operations (especially logout)
- **Handle authentication state** properly across route changes
- **Use context providers** for global state (auth, theme, etc.)
- **Implement proper error boundaries** for graceful failure handling

### API Integration
- **Use consistent API client** with proper error handling
- **Handle 404/500 errors** gracefully with user-friendly messages
- **Implement retry logic** for transient failures
- **Add loading states** for all async operations
- **Validate API responses** before using data
- **Update ALL references** when changing API route structures
- **Use semantic route prefixes** to avoid conflicts (e.g., /tenant-access vs /tenants)
- **Create corresponding frontend API routes** for all backend endpoints

### Routing & Navigation
- **Handle middleware redirects** carefully to avoid infinite loops
- **Use proper route protection** for authenticated pages
- **Implement proper logout flow** with state cleanup
- **Handle subdomain routing** for multi-tenant access

### TypeScript & Code Quality
- **Replace `any` types** with proper interfaces and types
- **Remove unused imports and variables** to prevent build errors
- **Use proper JSX escaping** for dynamic content
- **Implement proper error handling** with try-catch blocks
- **Add proper TypeScript interfaces** for all data structures

### Environment Configuration
- **Use `NEXT_PUBLIC_` prefix** for client-side environment variables
- **Never expose sensitive variables** to the client (no `NEXT_PUBLIC_` prefix)
- **Use consistent environment variable naming** with backend
- **Validate environment variables** in API routes and components
- **Handle missing environment variables** gracefully with fallbacks
- **Update all hardcoded URLs** when changing configuration
- **Test with different domain/port configurations** for flexibility

### Component & UI Development
- **ALWAYS check existing user-defined components first** before creating new ones
- **Use `@/components/ui-kit/` components** for complex UI patterns (DataTable, DialogForm, etc.)
- **Use `@/components/ui/` components** for basic UI elements (Button, Input, Card, etc.)
- **Use `@/utils/ui/` utilities** for common UI operations (dialogs, sheets, toasts, etc.)
- **Check `@/components/` for existing business logic components** before duplicating
- **Extend existing components** rather than creating similar ones from scratch
- **Follow established patterns** in existing user-defined components
- **Document new components** if they don't fit existing patterns
- **Use consistent naming conventions** with existing component library
- **Leverage existing TypeScript interfaces** from user-defined components

## üîí Security Best Practices

### Multi-Tenant Security
- **Validate tenant access** on every request
- **Implement proper data isolation** between tenants
- **Use secure session management** for impersonation
- **Audit all tenant access** and impersonation events
- **Implement rate limiting** for sensitive operations

### Authentication Security
- **Use secure JWT tokens** with proper expiration
- **Implement proper logout** with token invalidation
- **Use HTTP-only cookies** for sensitive data
- **Validate user permissions** before any operation
- **Implement proper CSRF protection**

## üêõ Debugging & Troubleshooting

### Common Issues & Solutions
- **Route conflicts**: Reorder routes (specific before parameterized)
- **Controller conflicts**: Multiple controllers with same prefix cause 404s
- **Build errors**: Remove unused imports, fix TypeScript errors
- **Database sync issues**: Reset migrations and regenerate Prisma client
- **Authentication loops**: Check middleware and redirect logic
- **API 404s**: Verify route ordering and backend server status

### Debugging Workflow
1. **Check browser console** for frontend errors
2. **Check backend logs** for server errors
3. **Verify API endpoints** with proper tools (Postman, curl)
4. **Check database state** and Prisma client generation
5. **Validate environment variables** and configuration

## üìã Development Workflow

### Before Making Changes
- **Understand the current architecture** and data flow
- **Check existing implementations** to avoid conflicts
- **Plan the changes** with proper error handling
- **Consider security implications** of any changes

### During Development
- **Test incrementally** - don't make too many changes at once
- **Use proper logging** to track execution flow
- **Handle edge cases** and error conditions
- **Maintain type safety** throughout the codebase

### After Making Changes
- **Test the complete flow** end-to-end
- **Check for linting errors** and fix them
- **Verify build process** works correctly
- **Test error scenarios** and edge cases
- **Update documentation** if needed

## üöÄ Performance & Scalability

### Database Performance
- **Use proper indexing** for tenant-specific queries
- **Implement connection pooling** for database efficiency
- **Optimize queries** to avoid N+1 problems
- **Use database transactions** for data consistency

### Frontend Performance
- **Implement proper loading states** for better UX
- **Use React.memo** for expensive components
- **Optimize bundle size** by removing unused dependencies
- **Implement proper caching** strategies

## üìö Code Organization

### File Structure
- **Group related functionality** in modules/controllers
- **Use consistent naming conventions** across the project
- **Separate concerns** (auth, business logic, UI)
- **Keep components focused** and single-purpose

### Component Hierarchy & Usage
- **Priority 1**: Use existing `@/components/ui-kit/` components for complex patterns
- **Priority 2**: Use existing `@/components/ui/` components for basic elements
- **Priority 3**: Use `@/utils/ui/` utilities for common operations
- **Priority 4**: Extend existing components with props/interfaces
- **Priority 5**: Create new components only if no suitable existing ones
- **Always check component library** before implementing new UI patterns
- **Follow established component patterns** for consistency
- **Use TypeScript interfaces** from existing components when possible
- **Document component usage** and dependencies clearly

### Code Quality
- **Write self-documenting code** with clear variable names
- **Add proper comments** for complex logic
- **Use consistent formatting** and style
- **Implement proper error handling** throughout

## üîÑ Testing Strategy

### Manual Testing Checklist
- [ ] Login/logout flow works correctly
- [ ] Tenant switching works without errors
- [ ] Impersonation flow is secure and functional
- [ ] API endpoints return expected responses
- [ ] Error handling works gracefully
- [ ] Build process completes without errors
- [ ] Linting passes without warnings
- [ ] UI components use existing user-defined components where appropriate
- [ ] No duplicate components created when suitable existing ones exist
- [ ] Component library is properly utilized across the application

### Automated Testing (Future)
- [ ] Unit tests for business logic
- [ ] Integration tests for API endpoints
- [ ] E2E tests for critical user flows
- [ ] Security tests for authentication/authorization

## üìù Documentation

### Code Documentation
- **Document complex business logic** with clear comments
- **Add JSDoc comments** for public APIs
- **Keep README files updated** with setup instructions
- **Document environment variables** and configuration

### Architecture Documentation
- **Maintain system architecture diagrams**
- **Document database schemas** and relationships
- **Keep API documentation** up to date
- **Document security considerations** and implementations

## üéØ Key Principles

1. **Security First**: Always consider security implications
2. **Type Safety**: Use TypeScript effectively, avoid `any`
3. **Error Handling**: Graceful degradation and user-friendly errors
4. **Testing**: Test incrementally and thoroughly
5. **Documentation**: Keep code and docs in sync
6. **Performance**: Consider scalability from the start
7. **User Experience**: Smooth, intuitive interactions
8. **Maintainability**: Clean, readable, well-organized code

## üö® Critical Reminders

- **Always restart backend** after route changes
- **Clear .next folder** when frontend build issues occur
- **Check route ordering** when API calls return 404
- **Validate tenant context** in all multi-tenant operations
- **Reset loading states** in all async operations
- **Handle authentication state** properly across navigation
- **Use proper error boundaries** for graceful failure handling
- **Validate environment variables** before starting services
- **Check for hardcoded domains/ports** when debugging connection issues
- **Update ALL environment references** when changing configuration
- **Check existing user-defined components** before creating new UI elements
- **Use component library hierarchy** (ui-kit ‚Üí ui ‚Üí utils ‚Üí extend ‚Üí create new)
